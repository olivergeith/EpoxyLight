#include <Adafruit_NeoPixel.h>
#include "EpoxyLight.h"
#include <Bounce2.h>

#define MODE_BUTTON_PIN 2
#define SPEED_BUTTON_PIN 3


// Parameter 1 = number of pixels in strip,  neopixel stick has 8
// Parameter 2 = pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_RGB     Pixels are wired for RGB bitstream
//   NEO_GRB     Pixels are wired for GRB bitstream, correct for neopixel stick
//   NEO_KHZ400  400 KHz bitstream (e.g. FLORA pixels)
//   NEO_KHZ800  800 KHz bitstream (e.g. High Density LED strip), correct for neopixel stick
Adafruit_NeoPixel stripD6 = Adafruit_NeoPixel(31, 6, NEO_GRB + NEO_KHZ800);
EpoxyLight ringD6(stripD6);

Bounce modeButton = Bounce();
Bounce speedButton = Bounce();

int modus = 0;
int speed = 5;
int millies = 0;
int deltaMillies = 5;

void setup() {
	millies = 0;

	// Setup the first button with an internal pull-up :
	// Button schließt gegen Masse
	pinMode(MODE_BUTTON_PIN, INPUT_PULLUP);
	modeButton.attach(MODE_BUTTON_PIN);
	modeButton.interval(5); // interval in ms

	pinMode(SPEED_BUTTON_PIN, INPUT_PULLUP);
	speedButton.attach(SPEED_BUTTON_PIN);
	speedButton.interval(5); // interval in ms

	ringD6.setup();
}

void loop() {
	millies = millies + deltaMillies;
	if (millies >= 5000)
		millies = 0;

	modeButton.update();
	if (modeButton.fell() == true) {
		incrementMode();
	}
	speedButton.update();
	if (speedButton.fell() == true) {
		incrementSpeed();
	}
	drawEpoxyLight();
	delay(deltaMillies);
}

void incrementMode() {
	modus++;
	ringD6.init();
	if (modus > 9) {
		modus = 0;
	}
}

void incrementSpeed() {
	speed++;
	if (speed > 20) {
		speed = 1;
	}
}



void drawEpoxyLight() {
	switch (modus) {
	default:
	case 0:
		ringD6.drawPoliceLight(millies, 5*speed);
		break;
	case 1:
		ringD6.drawWheelColorful(millies, 256, 16, 10*speed);
		break;
	case 2:
		ringD6.drawTrippleLauflichtWheeled(millies, 10*speed);
		break;
	case 3:
		ringD6.drawLauflichtBuildingUp(millies, 10*speed, 32);
		break;
	case 4:
		ringD6.drawWheel(millies, 1, 50*speed);
		break;
	case 5:
		ringD6.drawLauflichtRandomColor(millies, 10*speed);
		break;
	case 6:
		ringD6.drawRandomSegment(millies, 20*speed, 16);
		break;
	case 7:
		ringD6.drawRandomSegmentV2(millies, 20*speed, 16);
		break;
	case 8:
		ringD6.drawRandomSegmentV3(millies, 20*speed);
		break;
	case 9:
		ringD6.drawTrippleLauflichtWheeledTronLight(millies, 5*speed, 2);
		break;
	}
}



#include <inttypes.h>
#include "HardwareSerial.h"

// 12 Step Rotary Encoder with Click //
// https://www.sparkfun.com/products/9117 //
#define EncoderPinA 20  // Rotary Encoder Left Pin //
#define EncoderPinB 19  // Rotary Encoder Right Pin //
#define EncoderPinP 21  // Rotary Encoder Click //

// ======================================================================================= //
class Encoder
{
  public:
    Encoder()
    {
      pinMode(EncoderPinA, INPUT);
      digitalWrite(EncoderPinA, HIGH);
      pinMode(EncoderPinB, INPUT);
      digitalWrite(EncoderPinB, HIGH);
      pinMode(EncoderPinP, INPUT);
      digitalWrite(EncoderPinP, HIGH);

      Position = 0;
      Position2 = 0;
      Max = 127;
      Min = 0;
      clickMultiply = 10;
    }

    void Tick(void)
    {
      Position2 = (digitalRead(EncoderPinB) * 2) + digitalRead(EncoderPinA);;
      if (Position2 != Position)
      {
        isFwd = ((Position == 0) && (Position2 == 1)) || ((Position == 1) && (Position2 == 3)) ||
                ((Position == 3) && (Position2 == 2)) || ((Position == 2) && (Position2 == 0));
        if (!digitalRead(EncoderPinP)) {
          if (isFwd) Pos += clickMultiply;
          else Pos -= clickMultiply;
        }
        else {
          if (isFwd) Pos++;
          else Pos--;
        }
        if (Pos < Min) Pos = Min;
        if (Pos > Max) Pos = Max;
      }
      Position = Position2;
    }

    int getPos(void)
    {
      return (Pos / 4);
    }

    void setMinMax(int _Min, int _Max)
    {
      Min = _Min * 4;
      Max = _Max * 4;
      if (Pos < Min) Pos = Min;
      if (Pos > Max) Pos = Max;
    }

    void setClickMultiply(int _clickMultiply)
    {
      clickMultiply = _clickMultiply;
    }

  private:
    int clickMultiply;
    int Max;
    int Min;
    int Pos;
    int Position;
    int Position2;
    int isFwd;
};


